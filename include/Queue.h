#ifndef _GF_QUEUE_H
#define _GF_QUEUE_H

// ////////////////////////////////////////////////////////////
// @file Queue.h
// @author PJ O Halloran
// @date 30/03/2011
//
// Header for the template Queue container class(es).
//
// ////////////////////////////////////////////////////////////


// External Headers


// Project Headers
#include "GameBase.h"
#include "LinkedList.h"


// ////////////////////////////////////////////////////////////
//
//
// ////////////////////////////////////////////////////////////
namespace GameHalloran
{

	// ////////////////////////////////////////////////////////////
	// @class Queue
	// @author PJ O Halloran
	// 
	// A Queue (FIFO first in first out) data structure.
	//
	// The underlying implementation uses the LinkedList and as such
	// has O(1) time for inserting and popping elements into/from
	// the queue.
	//
	// ////////////////////////////////////////////////////////////
	template<typename ElementType>
		class Queue
	{
	private:

		LinkedList<ElementType> m_list;				///< Internal underlying data structure.

	public:

		// ////////////////////////////////////////////////////////////
		// Default constructor.
		//
		// ////////////////////////////////////////////////////////////
		explicit Queue() : m_list() { };

		// ////////////////////////////////////////////////////////////
		// Copy constructor.
		//
		// ////////////////////////////////////////////////////////////
		explicit Queue(const Queue &queueObj) : m_list(queueObj.m_list) { };

		// ////////////////////////////////////////////////////////////
		// Destructor.
		//
		// ////////////////////////////////////////////////////////////
		~Queue() { };

		// ////////////////////////////////////////////////////////////
		// Assign the contents of a Queue to this queue.
		//
		// ////////////////////////////////////////////////////////////
		void operator=(const Queue &rhs) { m_list = rhs.m_list; };

		// ////////////////////////////////////////////////////////////
		// Clear the queue.
		//
		// ////////////////////////////////////////////////////////////
		void Clear() { m_list.Clear(); };

		// ////////////////////////////////////////////////////////////
		// Get the size of the queue.
		//
		// ////////////////////////////////////////////////////////////
		U64 Size() { return (m_list.Size()); };

		// ////////////////////////////////////////////////////////////
		// Check if the list is empty.
		//
		// ////////////////////////////////////////////////////////////
		bool IsEmpty() const { return (m_list.IsEmpty()); };

		// ////////////////////////////////////////////////////////////
		// Insert an element into the queue.
		//
		// @param val The element to insert.
		//
		// @return bool True|False on success|failure.
		//
		// ////////////////////////////////////////////////////////////
		bool PushFront(const ElementType &val) { return (m_list.PushFront(val)); };

		// ////////////////////////////////////////////////////////////
		// Remove an element from the back of the queue.
		//
		// @param val Will hold the element removed from the queue (on
		//				success).
		//
		// @return bool True|False on success|failure.
		//
		// ////////////////////////////////////////////////////////////
		bool PopBack(ElementType &val) { return (m_list.Back(val) && m_list.PopBack()); };

	};
}

#endif